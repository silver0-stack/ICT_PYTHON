# SyntaxError와 Exception Handling
## 왜 `try-except`로 직접 `Syntax Error`를 잡을 수 없을까?
파이썬 인터프리터는 코드가 실행되기 전에 문법을 검사한다. 따라서 코드 내에 문법 오류(콜론 미스 등)가 있으면 실행 전에 에러가 발생하여 프로그램이 중단된다.
`try-except`블록은 코드 실행 중에 발생하는 예외를 처리하는 용도로 사용되므로, 파싱 과정에서 발생하는 `SyntaxError`는 `try-except`로 잡아낼 수 없는 것이다.

### 추가 예제: 정상적인 문법의 코드에서 `SyntaxError` 발생시키기
동적으로 코드를 실행할 때 의도적으로 `SyntaxError`를 발생시키고 이를 처리하는 예제를 보자
```python
def intentional_syntax_error():
    faulty_code ="print('Hello World'"
    
    try:
        exec(faulty_code)
    except SyntaxError as e:
        print(f"Caught SyntaxError: {e}")
        print("닫는 괄호가 필요합니다.")
        
# 함수 호출
intentional_syntax_error()
```
**출력**
```typescript
Caught SyntaxError: unexpected EOF while parsing (<string>, line 1)
닫는 괄호가 필요합니다.
```

**설명**
- 'faulty_code'는 `print('Hello Worlde',`로, 닫는 괄호가 빠져 있습니다.
- `exec(faulty_code)`를 실행하려고 하면 `SyntaxError`가 발생한다
- `try-except` 블록에서 이 에러를 잡아내고, 사용자에게 친절한 메시지 출력한다

### 함수 내에세 예외를 처리할지, 호출자에게 전달할지 결정하기
함수가 일반적인 작업을 수행할 때는 예외를 호출자에게 전달하고 ,함수가 예외르 처리해야 할 책임이 있을 때는 함수 내에세 처리한다.
```python
def get_element(lst, index):
    try:
        return lst[index]
    except IndexError as e:
        print("인덱스가 리스트 범위를 벗어났습니다.")
        print(f"IndexError: {e}")
        return None

# 호출자 함수
element = get_element([1, 2, 3], 5)
if element is None:
    print("유효하지 않은 인덱스입니다")
```

### 불필요한 예외 처리 피하기
예외를 불필요하게 처리하면 코드가 복잡해지고, 실제 문제를 놓칠 수 있습니다. 꼭 필요한 경우에만 예외를 처리해야 한다.
```python
# 비권장
try:
    # 코드
except Exception as e:
    print(f"예외 발생: {e}")

# 권장: 구체적인 예외만 처리
try:
    # 코드
except ValueError as e:
    print(f"값 오류 발생: {e}")
except TypeError as e:
    print(f"타입 오류 발생: {e}")
```

### 정리
- `SyntaxError` 는 코드 실행 전에 발생하기 때문에, 동일한 코드 내에서 `try-except` 로 처리할 수 없습니다.
- 동적으로 코드를 실행하는 경우(`exec()` 또는 `compile()` 사용)에는 `try-except` 블록으로 `SyntaxError`를 처리할 수 있습니다.
- 정확한 문법을 유지하는 것이 중요하며, 에디터의 문법 검사 기능을 활용하면 문법 오류를 미리 방지할 수 있습니다.



# 파이썬의 OOP Class
파이썬에서 **객체 지향 프로그래밍(Object-Oriented Programming, OOP)** 은 프로그램을 객체의 집합으로 구성하여 코드를 구조화하고 재사용성을 높이는 강력한 패러다임이다.
이번 TIL(Today I Learned)에서는 파이썬의 OOP 개념, 클래스 정의 방법, 상속, 다형성, 캡슐화 등 주요 개념들을 예제와 함께 살펴보자

1. [객체 지향 프로그래밍(OOP) 개요](##1.-객체-지향-프로그래밍(OOP)-개요)


## 1. 객체 지향 프로그래밍 개요
**객체 지향 프로그래밍(OOP)**은 프로그램을 객체의 집합으로 구성하여, 데이터와 기능을 함께 묶어 관리하는 프로그래밍 패러다임이다. 
OOP의 주요개념은 다음과 같다
- **클래스(Class)**: 객체를 생성하기 위한 청사진이나 템플릿
- **객체(Object)**: 클래스의 인스턴스로, 실제 메모리에 할당된 존재.
- **속성(Attribute)**: 객체의 상태나 데이터를 저장하는 변수
- **메소드(method)**: 객체가 수행할 수 있는 동작이나 기능을 정의하는 함수

OOP는 코드의 재사용성과 유지보수성을 높이며, 복잡한 시스템을 더 쉽게 관리할 수 있게 한다

---
## 2. 클래스(Class)와 객체(Object)
### 2.1. 클래스 정의하기
클래스는 `class` 키워드를 사용하여 정의한다. 클래스 내에는 속성과 메소드를 정의한다.
```python

```
### 2.2. 객체 생성하기
클래스를 기반으로 객체(인스턴스)를 생성할 수 있다.
```python

```

###2.3. 인스턴스 변수와 클래스 변수
- 인스턴스 변수: 각 객체마다 고유한 값을 가지는 변수
- 클래스 변수: 클래스 전체에서 공유되는 변수
```python

```
---

## 3. 생성자(Constructor)와 소멸자(Destructor)
### 3.1. `__init__` 메소드
`__init__` 메소드는 클래스의 생성자(Constructor)로, 객체가 생성될 때 자동 호출된다. 
주로 인스턴스 변수를 초기화하는 데 사용된다
```python

```
### 3.2. `__del__` 메소드
`__del__` 메소드는 소멸자(Destructor)로, 객체가 메모리에서 삭제될 때 호출된다.
리소스 해제나 정리 작업에 사용될 수 있다.
```python

```
---

## 4. 메소드(Method)와 속성(Attribute)
### 4.1. 인스턴스 메소드
인스턴스 메소드는 객체의 상태를 변경하거나 객체와 관련된 작업을 수행하는 메소드다.
첫 번째 매개변수로 항상 `self`를 사용한다.
```python

```
### 4.2. 클래스 메소드
클래스 메소드는 클래스 자체에 적용하는 메소드로, 첫 번째 매개변수로 `cls`를 사용한다
`@classmethod` 데코레이터로 정의한다.
```python

```
### 4.3. 정적 메소드
정적 메소드는 클래스나 객체의 상태와 무관하게 동작하는 메소드로, 
`@staticmethod` 데코레이터로 정의한다. 첫 번째 매개변수로 `self`나 `cls`를 사용하지 않는다.

```python


```
## 5. 상속(Inheritance)
상속은 기존 클래스(부모 클래스)를 기반으로 새로운 클래스(자식 클래스)를 정의하는 방법이다
이를 통해 코드의 재사용성과 확장성을 높일 수 있다.
### 5.1. 기본 상속
```python

```